from keras.callbacks import LambdaCallback
from keras.layers import Dense, LSTM, TimeDistributed, LayerNormalization
from keras import Sequential
import numpy as np
import tensorflow as tf
import pickle
import os
from PIL import Image, ImageChops
import matplotlib.pyplot as plt
import numpy as np
from PIL import Image, ImageFont, ImageDraw
import os
import imageio
from char_map import get_all_pixels, get_coords
import SPyQR


# Import metadata
m = pickle.load(open('obj/metadata', 'rb'))
max_char, char_dim, char_to_index, index_to_char = m['max_char'], m['char_dim'], m['encoder'], m['decoder']


def make_name(mdl, prompt: str = '') -> str:
    """
    Takes a model mdl and a prompt (default is empty) and returns text generated by the model

    :param mdl: keras.Sequential(), a ML model
    :param prompt: str, a string to prompt the RNN
    :return: str, a string generated by the RNN
    """
    generated_text = []
    x = np.zeros((1, max_char, char_dim))
    end = False
    i = 0

    for char in prompt.lower():
        x[0, i + 1, char_to_index[char]] = 1
        generated_text.append(char)
        i += 1

    while not end:
        probs = list(mdl.predict(x)[0, i])
        probs = probs / np.sum(probs)
        index = np.random.choice(range(char_dim), p=probs)
        if i == max_char - 2:
            character = '.'
            end = True
        else:
            character = index_to_char[index]
        generated_text.append(character)
        x[0, i + 1, index] = 1
        i += 1
        if character == '.':
            end = True

    return ''.join(generated_text)


def next_letter_dict(model: Sequential, prompt: str = '') -> str:
    name = []
    x = np.zeros((1, max_char, char_dim))
    i = 0

    for char in prompt.lower():
        x[0, i + 1, char_to_index[char]] = 1
        i += 1
        name.append(char)

    probs = list(model.predict(x)[0, i])

    d = {
        index_to_char[ix]: p for ix, p in enumerate(probs)
    }

    n = str.rjust(str(len(prompt)), 2, '0')
    name = n + prompt.replace('"', '-') + "_"

    return name, d


def name_dicts(model: Sequential, name: str):
    dicts = []
    prompts = [name[:i] for i in range(len(name.replace('.', '')) + 1)]

    for prompt in prompts:
        dicts.append(next_letter_dict(model, prompt))

    return dicts


# Open the keyboard image for later use
keyboard = Image.open(
    'obj/keyboard.png'
)


def get_frequencies(freq_dict):
    """Get the frequencies of certain keypresses."""
    heatmap_data = np.asarray([[0] * 57] * 21).astype('float')
    # Get the pixels covered by each character, and append these to pixels
    for char in freq_dict:
        coords = get_coords(char)
        if coords:
            for x, y in coords:
                heatmap_data[x][y] = freq_dict[char]

    # Return the normalised array
    return np.sqrt(np.sqrt(heatmap_data)) / np.sum(np.sqrt(np.sqrt(heatmap_data)))


def blend_and_save(freq_dict, filename, colormap='viridis', dots=600):
    """Plot a heatmap, upscale it to the keyboard and save a blended image."""
    # Clear the heatmap plot and axes
    plt.clf()
    plt.xticks([])
    plt.yticks([])
    plt.axis('off')
    # Display the data on the heatmap
    heatmap_data = get_frequencies(freq_dict)

    plt.imshow(
        heatmap_data, interpolation='lanczos', zorder=1, cmap=colormap
    )

    # Save the heatmap plot
    plt.savefig(
        'obj/heatmap.png',
        dpi=dots,
        pad_inches=0,
        transparent=True,
        bbox_inches='tight'
    )
    # Open the heatmap image
    heatmap = Image.open(
        'obj/heatmap.png'
    )
    # Resize the heatmap to the keyboard's size, with antialiasing
    heatmap = heatmap.resize(keyboard.size, Image.ANTIALIAS)
    heatmap.save(
        'obj/heatmap.png'
    )
    # Blend the images, and save
    blended = ImageChops.darker(keyboard, heatmap)
    blended.save(
        '{0}/{1}'.format(os.getcwd(), filename)
    )


def heatmaps(folder, prompt, model, predict=False):
    if predict:
        prompt = make_name(model, prompt)

    prompt = ' '.join(
        [
            i.title() if len(set(i) | {'i', 'v', 'x', 'l', 'c', 'd', 'm', '.'}) > 8 else i.upper()\
            for i in prompt.split(' ')
        ]
    )

    dicts = name_dicts(model, prompt)

    for name, d in dicts:
        blend_and_save(
            d,
            f'{folder}/{name}.png'
        )


class add_name_function:
    def __init__(self, font=None, size=30, title_loc=(15, 25), color=(237, 230, 211)):
        if font is None:
            try:
                self.font = ImageFont.truetype(font='consola', size=30)
            except Exception as e:
                raise Exception(f"font folder cannot be located - {e}")
        else:
            font = self.font
        self.size = size
        self.loc = title_loc
        self.color = color

    @staticmethod
    def text(filename):
        return filename.split('\\')[-1].replace('.png', '')[2:].replace('-', '"')

    @staticmethod
    def default_out(filename):
        *folders, file = filename.split('\\')
        file = "wtitle_" + file
        return '\\'.join(folders + [file, ])

    def __call__(self, in_, out_=None):
        im = Image.open(in_)
        im_editable = ImageDraw.Draw(im)

        t = self.text(in_)

        im_editable.text(self.loc, t, self.color, font=self.font)

        if out_ is None:
            out_ = self.default_out(in_)

        im.save(out_)


def make_gif(folder, duration=1, prefix="wtitle_", final_frame=2):
    wfiles = [
        imageio.imread(f'{folder}\\{file}') for file in os.listdir(folder) \
        if not os.path.isdir(file) and (prefix in file)
    ]

    for _ in range(final_frame):
        wfiles.append(wfiles[-1])

    name = folder.split('\\')[-1]

    imageio.mimsave(f'{folder}/{name}.gif', wfiles, duration=duration)


def add_title(folder):
    f = add_name_function()

    for file in os.listdir(folder):
        if not (os.path.isdir(file) or ("wtitle_" in file) or (".gif" in file)):
            f(f"{folder}\\{file}")


def prompt_to_gif(prompt, model, folder=None, predict=False):

    if folder is None:
        folder = prompt
    else:
        folder = folder + "\\" + prompt

    if not os.path.isdir(folder):
        os.mkdir(folder)

    # Generate heatmaps
    heatmaps(folder, prompt, model, predict=predict)

    # Add title
    add_title(folder)

    # Make gif
    make_gif(folder)


if __name__ == "__main__":
    imported = tf.keras.models.load_model('Models\\ByzantineRNN.h5')

    prompt_to_gif('Irene', imported, folder='Tapmaps', predict=True)

    print('Complete!')
